/** * ArrayBinaryTree.java *  * Copyright (c) Addison Wesley Publishing */package jsjf;import java.util.Iterator;import jsjf.exceptions.*;/** * Implements the BinaryTreeADT interface using an array. *  * @author Lewis/Chase */public class ArrayBinaryTree<T> implements BinaryTreeADT<T>{   protected int count;   protected T[] tree;   private final int capacity = 50;   /**    * Creates an empty binary tree.    */   public ArrayBinaryTree()    {      count = 0;      tree = (T[]) new Object[capacity];   }   /**    * Creates a binary tree with the specified element as    * its root.    *     * @param element the element to add to tree    */   public ArrayBinaryTree (T element)    {      count = 1;      tree = (T[]) new Object[capacity];      tree[0] = element;   }   /**    * Private method to expand capacity if full.    */   protected void expandCapacity()   {      T[] temp = (T[]) new Object[tree.length * 2];      for (int ct=0; ct < tree.length; ct++)         temp[ct] = tree[ct];            tree = temp;   }      /**    * Removes the left subtree of this binary tree.    */   public void removeLeftSubtree()    {   }   /**    * Removes the right subtree of this binary tree.    */   public void removeRightSubtree()    {   }      /**    * Deletes all nodes from this binary tree.    */   public void removeAllElements()    {      count = 0;            for (int ct=0; ct<tree.length; ct++)               tree[ct] = null;   }      /**    * Checks to see if this binary tree is empty.    *     * @return true if tree contains no elements, false otherwise    */   public boolean isEmpty()    {      return (count == 0);   }   /**    * Gets the size of this binary tree.    *     * @return the number of elements currently in this tree    */   public int size()    {      return count;   }      /**    * Searches this tree contains for an element that matches    * the specified target element.    *     * @param targetElement the search element    * @return true if element is in tree, false otherwise    */   public boolean contains (T targetElement)    {      boolean found = false;      for (int ct=0; ct<count && !found; ct++)         if (targetElement.equals(tree[ct]))	       found = true;      return found;   }   /**    * Returns a reference to the specified target element if    * it is found in this binary tree.    *     * @param targetElement the search element    * @return the element that matches the search element    * @throws NoSuchElementException if the specified target     * element is not found in the binary tree.    */   public T find (T targetElement) throws ElementNotFoundException    {      T temp=null;      boolean found = false;            for (int ct=0; ct<count && !found; ct++)         if (targetElement.equals(tree[ct]))         {	        found = true;            temp = tree[ct];         }      if (!found)         throw new ElementNotFoundException("binary tree");      return temp;   }   /**    * Gets this binary tree as a string.    *     * @return a string representation of the binary tree    */   public String toString()    {      ArrayUnorderedList<T> tempList = new ArrayUnorderedList<T>();      inorder (0, tempList);      return tempList.toString();   }   /**    * Performs an inorder traversal on this binary tree by calling     * an overloaded, recursive inorder method that starts with    * the root.    *     * @return an iterator over the tree    */   public Iterator<T> iteratorInOrder()    {      ArrayUnorderedList<T> tempList = new ArrayUnorderedList<T>();      inorder (0, tempList);      return tempList.iterator();   }   /**    * Performs a recursive inorder traversal.    *     * @param node current node    * @param tempList current list    */   protected void inorder (int node, ArrayUnorderedList<T> tempList)    {      if (node < tree.length)         if (tree[node] != null)         {            inorder (node*2+1, tempList);            tempList.addToRear(tree[node]);            inorder ((node+1)*2, tempList);         }   }   /**    * Performs an preorder traversal on this binary tree by     * calling an overloaded, recursive preorder method that     * starts with the root.    *     * @return an iterator over the tree    */   public Iterator<T> iteratorPreOrder()    {      ArrayUnorderedList<T> tempList = new ArrayUnorderedList<T>();      preorder (0, tempList);      return tempList.iterator();   }   /**    * Performs a recursive preorder traversal.    *     * @param node current node    * @param tempList current list    */   protected void preorder (int node, ArrayUnorderedList<T> tempList)    {      if (node < tree.length)         if (tree[node] != null)  	     {             tempList.addToRear(tree[node]);            inorder (node*2+1, tempList);            inorder ((node+1)*2, tempList);         }   }   /**    * Performs an postorder traversal on the binary tree by     * calling an overloaded, recursive postorder method that    * starts with the root.    *     * @return iterator over the tree    */   public Iterator<T> iteratorPostOrder()    {      ArrayUnorderedList<T> tempList = new ArrayUnorderedList<T>();      postorder (0, tempList);      return tempList.iterator();   }   /**    * Performs a recursive postorder traversal.    *     * @param node current node    * @param tempList current list    */   protected void postorder (int node, ArrayUnorderedList<T> tempList)    {      if (node < tree.length)         if (tree[node] != null)  	     {            inorder (node*2+1, tempList);             inorder ((node+1)*2, tempList);            tempList.addToRear(tree[node]);           }   }   /**    * Performs a level order traversal on this binary tree,     * using a tempList.    *     * @return an iterator over the tree    */   public Iterator<T> iteratorLevelOrder()    {      ArrayUnorderedList<T> tempList = new ArrayUnorderedList<T>();      int ct = 0; // current number of elements added to list      int i = 0; // current position in array            while (ct < count)      {         if (tree[i] != null)         {            tempList.addToRear(tree[i]);            ct++;         }         i++;      }            return tempList.iterator();   }}